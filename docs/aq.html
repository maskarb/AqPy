<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>aq API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aq</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># aq.py

# Solve 2-D aquifer pumping optimization

# Author: Michael Skarbek (maskarb@gmail.com)
# Version: 0.1.0

import itertools
import math
import random
import gurobipy as gu
import matplotlib.pyplot as plt
import numpy as np

#from .report import lindo

tupledict = gu.tupledict  # pylint: disable=E1101


def make_zero_tuple_dict(x, y):
    return tupledict((tup, 0) for tup in itertools.product(range(1, x), range(1, y)))


class Grid(object):
    def __init__(self, width: int, height: int):
        &#34;&#34;&#34;
        Parameters:
            width (int) :
            height (int):
                Dimensions of the aquifer
        &#34;&#34;&#34;
        self._width = width
        self._height = height
        self.Model = gu.Model()  # pylint: disable=E1101
        self.wells = make_zero_tuple_dict(self._width + 1, self._height + 1)
        self.LHS = make_zero_tuple_dict(self._width + 1, self._height + 1)
        self.well_coords = []
        self.contam_coords = []
        self._bounds = {
            &#34;top&#34;: [(i, 0) for i in range(1, self._width + 1)],
            &#34;bottom&#34;: [(i, self._height + 1) for i in range(1, self._width + 1)],
            &#34;left&#34;: [(0, j) for j in range(1, self._height + 1)],
            &#34;right&#34;: [(self._width + 1, j) for j in range(1, self._height + 1)],
        }
        self._heads = self.Model.addVars(
            itertools.product(range(1, self._width + 1), range(1, self._height + 1)),
            name=&#34;h&#34;,
        )
        self._solved = False
        self._init_boundary_heads()

    def add_boundary_contaminant(self, *args):
        &#34;&#34;&#34;Adds boundary (left, top, right, bottom) contaminants by
            adding model contraint. Head values within aquifer next to
            boundary are contrained to be greater than the boundary head

            Parameters:
                *args (str): the boundary side (&#39;left&#39;, &#39;top&#39;, &#39;right&#39;, &#39;bottom&#39;)
        &#34;&#34;&#34;
        w, h = self._width, self._height
        for bound in args:
            bound = bound.lower()
            if bound == &#34;right&#34;:
                self._boundary_helper(h + 1, w, w + 1, &#34;x&#34;)
            elif bound == &#34;left&#34;:
                self._boundary_helper(h + 1, 1, 0, &#34;x&#34;)
            elif bound == &#34;top&#34;:
                self._boundary_helper(w + 1, 1, 0, &#34;y&#34;)
            elif bound == &#34;bottom&#34;:
                self._boundary_helper(w + 1, h, h + 1, &#34;y&#34;)
            else:
                raise ValueError(
                    &#34;Boundary not specified correctly. Should be &#39;top&#39;, &#39;bottom&#39;, &#39;left&#39;, or &#39;right&#39;&#34;
                )
        self.Model.update()

    def add_boundary_heads(self, **kwargs):
        &#34;&#34;&#34;Specifies the boundary (left, top, right, bottom) head value.
            If a value is not provided for a boundary, it is assumed to 
            be a no-flow boundary.

            Parameters:
                **kwargs (str): the boundary side and its head value
        &#34;&#34;&#34;
        for k in kwargs.keys():
            if k.lower() not in [&#34;top&#34;, &#34;bottom&#34;, &#34;right&#34;, &#34;left&#34;]:
                raise ValueError(
                    &#34;Unknown argument assignment. Must specify head for &#39;top&#39;, &#39;left&#39;, &#39;right&#39;, or &#39;bottom&#39;.&#34;
                )
            self._add_bounds(k.lower(), kwargs[k])

    def add_cell_lengths(self, dx: float, dy: float = None):
        &#34;&#34;&#34;Specifies the height and width of the cells.

            Parameters:
                dx (float): length in x direction
                dy (float, optional): specifies length in y direction. If not
                    specified, dy = dx.
        &#34;&#34;&#34;
        self._dx = dx
        self._dy = dy if dy is not None else dx

    def add_contaminant(self, coords: tuple):
        &#34;&#34;&#34;Adds contaminant to aquifer by adding constrint to model.
            Cell heads surrounding contaminant are greater than or equal
            to contaminant head.

            Parameters:
                coords (tuple): The x,y coordinates of the contaminant.
        &#34;&#34;&#34;
        self.contam_coords.append(coords)
        x, y = coords
        for i in [-1, 1]:
            if self._heads[x + i, y] is not None:
                self.Model.addConstr(self._heads[x + i, y] &gt;= self._heads[x, y])
            if self._heads[x, y + i] is not None:
                self.Model.addConstr(self._heads[x, y + i] &gt;= self._heads[x, y])
        self.Model.update()

    def add_max_head(self, max_head: float = float(&#34;inf&#34;)):
        &#34;&#34;&#34;Adds upper bound for the head values.

            Parameters:
                max_head (float, optional): max head value. Defaults to +inf.
        &#34;&#34;&#34;
        self._max_head = max_head
        for i in self._heads:
            if isinstance(self._heads[i], gu.Var):  # pylint: disable=E1101
                self._heads[i].setAttr(&#34;ub&#34;, self._max_head)

    def add_min_head(self, min_head: float = 0):
        &#34;&#34;&#34;Adds lower bound for the head values.

            Parameters:
                min_head (float, optional): min head value. Defaults to 0.0.
        &#34;&#34;&#34;
        self._min_head = min_head
        for i in self._heads:
            if isinstance(self._heads[i], gu.Var):  # pylint: disable=E1101
                self._heads[i].setAttr(&#34;lb&#34;, self._min_head)

    def add_min_pump_rate(self, rate: float):
        &#34;&#34;&#34;Adds lower bound for the sum of the pumping rates. Adds
            constraint to model.

            Parameters:
                rate (float): min pumping rate.
        &#34;&#34;&#34;
        self.Model.addConstr(self.wells.sum() &gt;= rate)

    def add_objective(self, num: int):
        &#34;&#34;&#34;Adds objective function. Select from list:

            1: Maximize total pumping.
            2: Maximize heads throughout aquifer.

            Parameters:
                num (int): The objective function selection.
        &#34;&#34;&#34;
        if num == 1:
            self.Model.setObjective(
                self.wells.sum(), gu.GRB.MAXIMIZE  # pylint: disable=E1101
            )
        elif num == 2:
            temp = []
            for i in self._heads:
                if isinstance(self._heads[i], gu.Var):  # pylint: disable=E1101
                    temp.append(self._heads[i])
            self.Model.setObjective(sum(temp), gu.GRB.MAXIMIZE)  # pylint: disable=E1101
        else:
            raise ValueError(
                &#34;must add int corresponding to objective number. 1: max pumping. 2: max heads in aquifer.&#34;
            )
        self.Model.update()

    def add_trans(self, tx: float, sd: float = 0, distribution: str = &#34;uniform&#34;):
        &#34;&#34;&#34;Adds transmissivity distribution functions.

            Parameters:
                tx (float): Mean of transmissivity in x-direction.
                sd (float, optional): Standard deviation for distribution 
                    function. Default is 0.0.
                distribution (str): Sets the transmissivity distribution 
                    function. Default is &#39;uniform.&#39; Select from &#39;uniform&#39;, 
                    &#39;normal&#39; or &#39;lognormal.&#39;
        &#34;&#34;&#34;
        self._Tx = self._dist_helper(tx, sd, distribution)
        self._Ty = self._dist_helper(tx, sd, distribution)

    def add_units(self, length: str = &#34;m&#34;, time: str = &#34;d&#34;):
        &#34;&#34;&#34;Adds dimensional units.

            Parameters:
                length (str, optional): units for length. Default to &#39;m&#39; (meters).
                time (str, optional): units for time. Default to &#39;d&#39; (days).
        &#34;&#34;&#34;
        self._length = &#34;m&#34; if length == &#34;m&#34; else &#34;ft&#34;
        self._rate = f&#34;cm{time}&#34; if length == &#34;m&#34; else f&#34;cf{time}&#34;
        self._sink = f&#34;mp{time}&#34; if length == &#34;m&#34; else f&#34;fp{time}&#34;

    def add_wells(self, coords):
        &#34;&#34;&#34;Adds the wells to the aquifer.

            Parameters:
                coords (List(tuple)): The (x,y) coordinates for the wells. 
                    Must be provided as a single tuple (x,y) or as a list 
                    of tuples [(x1,y1), (x2,y2) ...]
        &#34;&#34;&#34;
        if type(coords) is tuple:
            coords = [coords]
        if type(coords[0]) is not tuple:
            raise ValueError(
                &#34;Well coordinates must be added as a list of tuples, e.g. [(x1, y1), (x2, y2)]&#34;
            )
        for coord in coords:
            self.wells[coord] = self.Model.addVar(name=f&#34;pump{coord}&#34;, lb=float(&#34;-inf&#34;))
            self.well_coords.append(coord)
        self.Model.update()

    def optimize(self):
        &#34;&#34;&#34;This function finalizes the model constraints, updates the model,
            and then tries to solve the model. If optimal solution is found,
            the head values are gathered for printing purposes later.
        &#34;&#34;&#34;
        self._add_constraints()
        self.Model.update()
        self.Model.optimize()
        if (
            self.Model.Status == 2
        ):  # Status = 2 means optimal solution found and model is solved
            self._solved = True
            self._head_results = self._get_head_results()
            print(&#34;OPTIMIZATION COMPLETE&#34;)
        else:
            self._head_results = None
            print(&#34;OPTIMIZATION NOT COMPLETE&#34;)

    def print_grid_results(self, filename: str = &#34;heads&#34;):
        &#34;&#34;&#34;Prints grid head values to the terminal and to csv file.

            Parameters:
                filename (str, optional): filename (without extension) to 
                    save grid head values.
        &#34;&#34;&#34;
        if self._solved:
            np.savetxt(f&#34;{filename}.csv&#34;, self._head_results, fmt=&#34;%.5f&#34;, delimiter=&#34;,&#34;)
            print(f&#34;Results: in {self._length}&#34;)
            with np.printoptions(
                precision=3, suppress=True, nanstr=&#34;bound&#34;, floatmode=&#34;fixed&#34;
            ):
                print(self._head_results)
        else:
            print(&#34;No results to print.&#34;)

    def print_pump_results(self, filename: str = &#34;pumps&#34;):
        &#34;&#34;&#34;Prints pump values to the terminal and to txt file.

            Parameters:
                filename (str, optional): filename (without extension) to
                    save pump values.
        &#34;&#34;&#34;
        if self._solved:
            with open(f&#34;{filename}.txt&#34;, &#34;w&#34;) as f:
                f.write(&#34;Pump Results\n&#34;)
                print(&#34;Pump Results&#34;)
                for key in self.wells:
                    if isinstance(self.wells[key], gu.Var):  # pylint: disable=E1101
                        line = f&#34;{key}: {self.wells[key].X:10.5f} {self._sink}, head ({self._length}): {self._heads[key].X:6.2f}&#34;
                        print(line)
                        f.write(line + &#34;\n&#34;)
                q = self.wells.sum().getValue()
                print(f&#34;Total Flow (q): {q:.2f} {self._sink}&#34;)
                print(f&#34;Total Flow (W): {q*self._dx*self._dy:.2f} {self._rate}&#34;)
                f.write(f&#34;Total Flow (q): {q:.2f} {self._sink}\n&#34;)
                f.write(f&#34;Total Flow (W): {q*self._dx*self._dy:.2f} {self._rate}\n&#34;)
        else:
            print(&#34;No results to print.&#34;)

    def print_map(self, filename: str = &#34;map&#34;, text: bool = False, wells: bool = True):
        &#34;&#34;&#34;Generates heat map of the aquifer based on head values.

            Parameters:
                filename (str, optional): filename (without extension) to save 
                    image of heat map.
                text (bool, optional): Adds the numerical value to the map.
                    Default is False.
                    Really big aquifers will not show this value very well.
                wells (bool, optional): Adds +/-W to the well locations. 
                    Default is True. The W does not scale with aquifer size, 
                    so it will not show up very well in really large aquifers.
        &#34;&#34;&#34;
        if self._solved:
            grid = self._head_results
            vmin = np.nanmin(grid)
            vmax = np.nanmax(grid)
            for x, y in self.contam_coords:
                grid[y][x] = vmax + 1
            current_cmap = plt.cm.get_cmap(&#34;Blues_r&#34;)
            current_cmap.set_bad(color=&#34;gray&#34;)
            current_cmap.set_over(color=&#34;red&#34;)
            plt.imshow(grid, cmap=current_cmap, vmin=vmin, vmax=vmax)
            for i, j in self.well_coords:
                label = &#34;-W&#34; if self.wells[(i, j)].X &gt;= 0 else &#34;+W&#34;
                plt.text(i, j, label, ha=&#34;center&#34;, va=&#34;center&#34;)
            if text:
                for (j, i), label in np.ndenumerate(grid):
                    plt.text(i, j, round(label, 1), ha=&#34;center&#34;, va=&#34;center&#34;)
            plt.colorbar()
            plt.savefig(f&#34;{filename}.pdf&#34;, dpi=300)
            plt.show()
        else:
            print(&#34;No results to print.&#34;)

    def print_report(self):
        &#34;&#34;&#34;Generates lindo style report.&#34;&#34;&#34;
        if self._solved:
            lindo(self.Model)
        else:
            print(&#34;No results to print.&#34;)

    def _add_bounds(self, key, val):
        for coord in self._bounds[key]:
            self._heads[coord] = val

    def _add_constraints(self):
        self._add_LHS()
        self.Model.addConstrs(
            self.LHS[key] == self.wells[key] for key in self.LHS.keys()
        )
        self.Model.update()

    def _add_LHS(self):
        for i in range(1, self._width + 1):
            for j in range(1, self._height + 1):
                tx, ty = next(self._Tx), next(self._Ty)
                self._flow_helper((tx, ty), (i, j), (i, j - 1), &#34;y&#34;)  # direction: top
                self._flow_helper((tx, ty), (i, j), (i + 1, j), &#34;x&#34;)  # direction: right
                self._flow_helper(
                    (tx, ty), (i, j), (i, j + 1), &#34;y&#34;
                )  # direction: bottom
                self._flow_helper((tx, ty), (i, j), (i - 1, j), &#34;x&#34;)  # direction: left
        self.Model.update()

    def _boundary_helper(self, a, b, c, direc):
        if direc == &#34;x&#34;:
            for j in range(1, a):
                self.Model.addConstr(self._heads[b, j] &gt;= self._heads[c, j])
                self.contam_coords.append((c, j))
        elif direc == &#34;y&#34;:
            for i in range(1, a):
                self.Model.addConstr(self._heads[i, b] &gt;= self._heads[i, c])
                self.contam_coords.append((i, c))

    def _dist_helper(self, mean, sd, distribution):
        if distribution == &#34;normal&#34; or distribution == &#34;uniform&#34;:
            sd = 0 if distribution == &#34;uniform&#34; else sd
            while True:
                yield random.gauss(mean, sd)
        elif &#34;log&#34; in distribution:
            if sd == 0:
                raise ValueError(
                    &#34;Standard deviation for lognormal distribution must be specified.&#34;
                )
            while True:
                var = sd / mean
                mu_ln_x = 0.5 * math.log(mean ** 2 / (1 + var ** 2))
                sd_ln_x = math.sqrt(math.log(var ** 2 + 1))
                yield random.lognormvariate(mu_ln_x, sd_ln_x)
        else:
            raise ValueError(
                &#34;Distribution must be specified in add_trans(). Select from &#39;uniform,&#39; &#39;normal,&#39; and &#39;lognormal.&#39;&#34;
            )

    def _flow_helper(self, trans: tuple, coord: tuple, dif: tuple, direc: str):
        tx, ty = trans
        if direc == &#34;x&#34;:
            if self._heads[dif] is not None:
                self.LHS[coord] += (
                    tx * (self._heads[dif] - self._heads[coord]) / (self._dx ** 2)
                )
        elif direc == &#34;y&#34;:
            if self._heads[dif] is not None:
                self.LHS[coord] += (
                    ty * (self._heads[dif] - self._heads[coord]) / (self._dy ** 2)
                )

    def _get_head_results(self):
        temp = np.full((self._width + 2, self._height + 2), np.nan)
        for i in self._heads:
            if isinstance(self._heads[i], gu.Var):  # pylint: disable=E1101
                temp[i] = self._heads[i].X
            else:
                temp[i] = self._heads[i]
        return temp.T

    def _init_boundary_heads(self):
        for v in self._bounds.values():
            for coord in v:
                self._heads[coord] = None


if __name__ == &#34;__main__&#34;:
    width, height = 8, 8
    g = Grid(width, height)
    g.add_units(&#34;ft&#34;, &#34;d&#34;)
    g.add_min_head(23)
    g.add_cell_lengths(500)
    g.add_trans(12500, sd=500, distribution=&#34;normal&#34;)

    wells = [
        (3, 3),
        (3, 5),
        (3, 7),
        (4, 3),
        (4, 5),
        (4, 7),
        (5, 3),
        (5, 5),
        (5, 7),
        (6, 3),
        (6, 5),
        (6, 7),
    ]
    g.add_wells(wells)
    g.add_boundary_heads(right=29.4, left=39)
    # g.add_boundary_contaminant(&#34;right&#34;)
    g.add_contaminant((6, 2))
    g.add_objective(1)

    g.optimize()
    g.print_report()
    g.print_grid_results()
    g.print_pump_results()
    g.print_map()
    print()

&#34;&#34;&#34;
from aqpy import aq
g = aq.Grid(8, 8)
g.add_units(&#39;ft&#39;, &#39;d&#39;)
wells = [(3,3),(5,5),(7,7)]
g.add_wells(wells)
g.add_min_pump_rate(1.5)
g.add_min_head(23)
g.add_cell_lengths(500)
g.add_trans(12500, 100, &#39;normal&#39;)
g.add_boundary_heads(left=39, right=29.4)
g.add_objective(2)
g.optimize()
Optimize a model with 65 rows, 67 columns and 294 nonzeros
Coefficient statistics:
  Matrix range     [5e-02, 1e+00]
  Objective range  [1e+00, 1e+00]
  Bounds range     [2e+01, 2e+01]
  RHS range        [1e+00, 2e+00]
Presolve removed 37 rows and 37 columns
Presolve time: 0.00s
Presolved: 28 rows, 30 columns, 246 nonzeros

Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    3.7793103e+32   1.140819e+31   3.779310e+02      0s
      29    1.9593423e+03   0.000000e+00   0.000000e+00      0s

Solved in 29 iterations and 0.00 seconds
Optimal objective  1.959342309e+03
OPTIMIZATION IS COMPLETE
&gt;&gt;&gt; g.print_pump_results()
Pump Results
(3, 3):    1.17494 fpd, head (ft):  23.00
(5, 5):   -0.45900 fpd, head (ft):  33.04
(7, 7):    0.78406 fpd, head (ft):  23.00
Total Flow (q): 1.50 fpd
Total Flow (W): 375000.00 cfd
&gt;&gt;&gt; g.print_grid()
Results: in ft
[[ bound  bound  bound  bound  bound  bound  bound  bound  bound  bound]
 [39.000 35.566 32.373 29.939 29.182 29.114 29.194 29.269 29.335 29.400]
 [39.000 35.325 31.615 28.261 28.492 28.968 29.197 29.280 29.335 29.400]
 [39.000 35.121 30.499 23.000 27.557 29.067 29.348 29.318 29.324 29.400]
 [39.000 35.658 32.260 29.181 29.670 30.396 29.808 29.321 29.242 29.400]
 [39.000 36.253 33.700 31.796 31.544 33.040 30.168 28.914 28.925 29.400]
 [39.000 36.653 34.493 32.759 31.672 30.869 28.912 27.243 28.144 29.400]
 [39.000 36.866 34.858 33.076 31.514 29.855 27.367 23.000 27.009 29.400]
 [39.000 36.954 34.995 33.175 31.452 29.669 27.700 26.063 27.491 29.400]
 [ bound  bound  bound  bound  bound  bound  bound  bound  bound  bound]]

&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="aq.make_zero_tuple_dict"><code class="name flex">
<span>def <span class="ident">make_zero_tuple_dict</span></span>(<span>x, y)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def make_zero_tuple_dict(x, y):
    return tupledict((tup, 0) for tup in itertools.product(range(1, x), range(1, y)))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aq.Grid"><code class="flex name class">
<span>class <span class="ident">Grid</span></span>
<span>(</span><span>width, height)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="parameters">Parameters</h2>
<p>width (int) :
height (int):
Dimensions of the aquifer</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Grid(object):
    def __init__(self, width: int, height: int):
        &#34;&#34;&#34;
        Parameters:
            width (int) :
            height (int):
                Dimensions of the aquifer
        &#34;&#34;&#34;
        self._width = width
        self._height = height
        self.Model = gu.Model()  # pylint: disable=E1101
        self.wells = make_zero_tuple_dict(self._width + 1, self._height + 1)
        self.LHS = make_zero_tuple_dict(self._width + 1, self._height + 1)
        self.well_coords = []
        self.contam_coords = []
        self._bounds = {
            &#34;top&#34;: [(i, 0) for i in range(1, self._width + 1)],
            &#34;bottom&#34;: [(i, self._height + 1) for i in range(1, self._width + 1)],
            &#34;left&#34;: [(0, j) for j in range(1, self._height + 1)],
            &#34;right&#34;: [(self._width + 1, j) for j in range(1, self._height + 1)],
        }
        self._heads = self.Model.addVars(
            itertools.product(range(1, self._width + 1), range(1, self._height + 1)),
            name=&#34;h&#34;,
        )
        self._solved = False
        self._init_boundary_heads()

    def add_boundary_contaminant(self, *args):
        &#34;&#34;&#34;Adds boundary (left, top, right, bottom) contaminants by
            adding model contraint. Head values within aquifer next to
            boundary are contrained to be greater than the boundary head

            Parameters:
                *args (str): the boundary side (&#39;left&#39;, &#39;top&#39;, &#39;right&#39;, &#39;bottom&#39;)
        &#34;&#34;&#34;
        w, h = self._width, self._height
        for bound in args:
            bound = bound.lower()
            if bound == &#34;right&#34;:
                self._boundary_helper(h + 1, w, w + 1, &#34;x&#34;)
            elif bound == &#34;left&#34;:
                self._boundary_helper(h + 1, 1, 0, &#34;x&#34;)
            elif bound == &#34;top&#34;:
                self._boundary_helper(w + 1, 1, 0, &#34;y&#34;)
            elif bound == &#34;bottom&#34;:
                self._boundary_helper(w + 1, h, h + 1, &#34;y&#34;)
            else:
                raise ValueError(
                    &#34;Boundary not specified correctly. Should be &#39;top&#39;, &#39;bottom&#39;, &#39;left&#39;, or &#39;right&#39;&#34;
                )
        self.Model.update()

    def add_boundary_heads(self, **kwargs):
        &#34;&#34;&#34;Specifies the boundary (left, top, right, bottom) head value.
            If a value is not provided for a boundary, it is assumed to 
            be a no-flow boundary.

            Parameters:
                **kwargs (str): the boundary side and its head value
        &#34;&#34;&#34;
        for k in kwargs.keys():
            if k.lower() not in [&#34;top&#34;, &#34;bottom&#34;, &#34;right&#34;, &#34;left&#34;]:
                raise ValueError(
                    &#34;Unknown argument assignment. Must specify head for &#39;top&#39;, &#39;left&#39;, &#39;right&#39;, or &#39;bottom&#39;.&#34;
                )
            self._add_bounds(k.lower(), kwargs[k])

    def add_cell_lengths(self, dx: float, dy: float = None):
        &#34;&#34;&#34;Specifies the height and width of the cells.

            Parameters:
                dx (float): length in x direction
                dy (float, optional): specifies length in y direction. If not
                    specified, dy = dx.
        &#34;&#34;&#34;
        self._dx = dx
        self._dy = dy if dy is not None else dx

    def add_contaminant(self, coords: tuple):
        &#34;&#34;&#34;Adds contaminant to aquifer by adding constrint to model.
            Cell heads surrounding contaminant are greater than or equal
            to contaminant head.

            Parameters:
                coords (tuple): The x,y coordinates of the contaminant.
        &#34;&#34;&#34;
        self.contam_coords.append(coords)
        x, y = coords
        for i in [-1, 1]:
            if self._heads[x + i, y] is not None:
                self.Model.addConstr(self._heads[x + i, y] &gt;= self._heads[x, y])
            if self._heads[x, y + i] is not None:
                self.Model.addConstr(self._heads[x, y + i] &gt;= self._heads[x, y])
        self.Model.update()

    def add_max_head(self, max_head: float = float(&#34;inf&#34;)):
        &#34;&#34;&#34;Adds upper bound for the head values.

            Parameters:
                max_head (float, optional): max head value. Defaults to +inf.
        &#34;&#34;&#34;
        self._max_head = max_head
        for i in self._heads:
            if isinstance(self._heads[i], gu.Var):  # pylint: disable=E1101
                self._heads[i].setAttr(&#34;ub&#34;, self._max_head)

    def add_min_head(self, min_head: float = 0):
        &#34;&#34;&#34;Adds lower bound for the head values.

            Parameters:
                min_head (float, optional): min head value. Defaults to 0.0.
        &#34;&#34;&#34;
        self._min_head = min_head
        for i in self._heads:
            if isinstance(self._heads[i], gu.Var):  # pylint: disable=E1101
                self._heads[i].setAttr(&#34;lb&#34;, self._min_head)

    def add_min_pump_rate(self, rate: float):
        &#34;&#34;&#34;Adds lower bound for the sum of the pumping rates. Adds
            constraint to model.

            Parameters:
                rate (float): min pumping rate.
        &#34;&#34;&#34;
        self.Model.addConstr(self.wells.sum() &gt;= rate)

    def add_objective(self, num: int):
        &#34;&#34;&#34;Adds objective function. Select from list:

            1: Maximize total pumping.
            2: Maximize heads throughout aquifer.

            Parameters:
                num (int): The objective function selection.
        &#34;&#34;&#34;
        if num == 1:
            self.Model.setObjective(
                self.wells.sum(), gu.GRB.MAXIMIZE  # pylint: disable=E1101
            )
        elif num == 2:
            temp = []
            for i in self._heads:
                if isinstance(self._heads[i], gu.Var):  # pylint: disable=E1101
                    temp.append(self._heads[i])
            self.Model.setObjective(sum(temp), gu.GRB.MAXIMIZE)  # pylint: disable=E1101
        else:
            raise ValueError(
                &#34;must add int corresponding to objective number. 1: max pumping. 2: max heads in aquifer.&#34;
            )
        self.Model.update()

    def add_trans(self, tx: float, sd: float = 0, distribution: str = &#34;uniform&#34;):
        &#34;&#34;&#34;Adds transmissivity distribution functions.

            Parameters:
                tx (float): Mean of transmissivity in x-direction.
                sd (float, optional): Standard deviation for distribution 
                    function. Default is 0.0.
                distribution (str): Sets the transmissivity distribution 
                    function. Default is &#39;uniform.&#39; Select from &#39;uniform&#39;, 
                    &#39;normal&#39; or &#39;lognormal.&#39;
        &#34;&#34;&#34;
        self._Tx = self._dist_helper(tx, sd, distribution)
        self._Ty = self._dist_helper(tx, sd, distribution)

    def add_units(self, length: str = &#34;m&#34;, time: str = &#34;d&#34;):
        &#34;&#34;&#34;Adds dimensional units.

            Parameters:
                length (str, optional): units for length. Default to &#39;m&#39; (meters).
                time (str, optional): units for time. Default to &#39;d&#39; (days).
        &#34;&#34;&#34;
        self._length = &#34;m&#34; if length == &#34;m&#34; else &#34;ft&#34;
        self._rate = f&#34;cm{time}&#34; if length == &#34;m&#34; else f&#34;cf{time}&#34;
        self._sink = f&#34;mp{time}&#34; if length == &#34;m&#34; else f&#34;fp{time}&#34;

    def add_wells(self, coords):
        &#34;&#34;&#34;Adds the wells to the aquifer.

            Parameters:
                coords (List(tuple)): The (x,y) coordinates for the wells. 
                    Must be provided as a single tuple (x,y) or as a list 
                    of tuples [(x1,y1), (x2,y2) ...]
        &#34;&#34;&#34;
        if type(coords) is tuple:
            coords = [coords]
        if type(coords[0]) is not tuple:
            raise ValueError(
                &#34;Well coordinates must be added as a list of tuples, e.g. [(x1, y1), (x2, y2)]&#34;
            )
        for coord in coords:
            self.wells[coord] = self.Model.addVar(name=f&#34;pump{coord}&#34;, lb=float(&#34;-inf&#34;))
            self.well_coords.append(coord)
        self.Model.update()

    def optimize(self):
        &#34;&#34;&#34;This function finalizes the model constraints, updates the model,
            and then tries to solve the model. If optimal solution is found,
            the head values are gathered for printing purposes later.
        &#34;&#34;&#34;
        self._add_constraints()
        self.Model.update()
        self.Model.optimize()
        if (
            self.Model.Status == 2
        ):  # Status = 2 means optimal solution found and model is solved
            self._solved = True
            self._head_results = self._get_head_results()
            print(&#34;OPTIMIZATION COMPLETE&#34;)
        else:
            self._head_results = None
            print(&#34;OPTIMIZATION NOT COMPLETE&#34;)

    def print_grid_results(self, filename: str = &#34;heads&#34;):
        &#34;&#34;&#34;Prints grid head values to the terminal and to csv file.

            Parameters:
                filename (str, optional): filename (without extension) to 
                    save grid head values.
        &#34;&#34;&#34;
        if self._solved:
            np.savetxt(f&#34;{filename}.csv&#34;, self._head_results, fmt=&#34;%.5f&#34;, delimiter=&#34;,&#34;)
            print(f&#34;Results: in {self._length}&#34;)
            with np.printoptions(
                precision=3, suppress=True, nanstr=&#34;bound&#34;, floatmode=&#34;fixed&#34;
            ):
                print(self._head_results)
        else:
            print(&#34;No results to print.&#34;)

    def print_pump_results(self, filename: str = &#34;pumps&#34;):
        &#34;&#34;&#34;Prints pump values to the terminal and to txt file.

            Parameters:
                filename (str, optional): filename (without extension) to
                    save pump values.
        &#34;&#34;&#34;
        if self._solved:
            with open(f&#34;{filename}.txt&#34;, &#34;w&#34;) as f:
                f.write(&#34;Pump Results\n&#34;)
                print(&#34;Pump Results&#34;)
                for key in self.wells:
                    if isinstance(self.wells[key], gu.Var):  # pylint: disable=E1101
                        line = f&#34;{key}: {self.wells[key].X:10.5f} {self._sink}, head ({self._length}): {self._heads[key].X:6.2f}&#34;
                        print(line)
                        f.write(line + &#34;\n&#34;)
                q = self.wells.sum().getValue()
                print(f&#34;Total Flow (q): {q:.2f} {self._sink}&#34;)
                print(f&#34;Total Flow (W): {q*self._dx*self._dy:.2f} {self._rate}&#34;)
                f.write(f&#34;Total Flow (q): {q:.2f} {self._sink}\n&#34;)
                f.write(f&#34;Total Flow (W): {q*self._dx*self._dy:.2f} {self._rate}\n&#34;)
        else:
            print(&#34;No results to print.&#34;)

    def print_map(self, filename: str = &#34;map&#34;, text: bool = False, wells: bool = True):
        &#34;&#34;&#34;Generates heat map of the aquifer based on head values.

            Parameters:
                filename (str, optional): filename (without extension) to save 
                    image of heat map.
                text (bool, optional): Adds the numerical value to the map.
                    Default is False.
                    Really big aquifers will not show this value very well.
                wells (bool, optional): Adds +/-W to the well locations. 
                    Default is True. The W does not scale with aquifer size, 
                    so it will not show up very well in really large aquifers.
        &#34;&#34;&#34;
        if self._solved:
            grid = self._head_results
            vmin = np.nanmin(grid)
            vmax = np.nanmax(grid)
            for x, y in self.contam_coords:
                grid[y][x] = vmax + 1
            current_cmap = plt.cm.get_cmap(&#34;Blues_r&#34;)
            current_cmap.set_bad(color=&#34;gray&#34;)
            current_cmap.set_over(color=&#34;red&#34;)
            plt.imshow(grid, cmap=current_cmap, vmin=vmin, vmax=vmax)
            for i, j in self.well_coords:
                label = &#34;-W&#34; if self.wells[(i, j)].X &gt;= 0 else &#34;+W&#34;
                plt.text(i, j, label, ha=&#34;center&#34;, va=&#34;center&#34;)
            if text:
                for (j, i), label in np.ndenumerate(grid):
                    plt.text(i, j, round(label, 1), ha=&#34;center&#34;, va=&#34;center&#34;)
            plt.colorbar()
            plt.savefig(f&#34;{filename}.pdf&#34;, dpi=300)
            plt.show()
        else:
            print(&#34;No results to print.&#34;)

    def print_report(self):
        &#34;&#34;&#34;Generates lindo style report.&#34;&#34;&#34;
        if self._solved:
            lindo(self.Model)
        else:
            print(&#34;No results to print.&#34;)

    def _add_bounds(self, key, val):
        for coord in self._bounds[key]:
            self._heads[coord] = val

    def _add_constraints(self):
        self._add_LHS()
        self.Model.addConstrs(
            self.LHS[key] == self.wells[key] for key in self.LHS.keys()
        )
        self.Model.update()

    def _add_LHS(self):
        for i in range(1, self._width + 1):
            for j in range(1, self._height + 1):
                tx, ty = next(self._Tx), next(self._Ty)
                self._flow_helper((tx, ty), (i, j), (i, j - 1), &#34;y&#34;)  # direction: top
                self._flow_helper((tx, ty), (i, j), (i + 1, j), &#34;x&#34;)  # direction: right
                self._flow_helper(
                    (tx, ty), (i, j), (i, j + 1), &#34;y&#34;
                )  # direction: bottom
                self._flow_helper((tx, ty), (i, j), (i - 1, j), &#34;x&#34;)  # direction: left
        self.Model.update()

    def _boundary_helper(self, a, b, c, direc):
        if direc == &#34;x&#34;:
            for j in range(1, a):
                self.Model.addConstr(self._heads[b, j] &gt;= self._heads[c, j])
                self.contam_coords.append((c, j))
        elif direc == &#34;y&#34;:
            for i in range(1, a):
                self.Model.addConstr(self._heads[i, b] &gt;= self._heads[i, c])
                self.contam_coords.append((i, c))

    def _dist_helper(self, mean, sd, distribution):
        if distribution == &#34;normal&#34; or distribution == &#34;uniform&#34;:
            sd = 0 if distribution == &#34;uniform&#34; else sd
            while True:
                yield random.gauss(mean, sd)
        elif &#34;log&#34; in distribution:
            if sd == 0:
                raise ValueError(
                    &#34;Standard deviation for lognormal distribution must be specified.&#34;
                )
            while True:
                var = sd / mean
                mu_ln_x = 0.5 * math.log(mean ** 2 / (1 + var ** 2))
                sd_ln_x = math.sqrt(math.log(var ** 2 + 1))
                yield random.lognormvariate(mu_ln_x, sd_ln_x)
        else:
            raise ValueError(
                &#34;Distribution must be specified in add_trans(). Select from &#39;uniform,&#39; &#39;normal,&#39; and &#39;lognormal.&#39;&#34;
            )

    def _flow_helper(self, trans: tuple, coord: tuple, dif: tuple, direc: str):
        tx, ty = trans
        if direc == &#34;x&#34;:
            if self._heads[dif] is not None:
                self.LHS[coord] += (
                    tx * (self._heads[dif] - self._heads[coord]) / (self._dx ** 2)
                )
        elif direc == &#34;y&#34;:
            if self._heads[dif] is not None:
                self.LHS[coord] += (
                    ty * (self._heads[dif] - self._heads[coord]) / (self._dy ** 2)
                )

    def _get_head_results(self):
        temp = np.full((self._width + 2, self._height + 2), np.nan)
        for i in self._heads:
            if isinstance(self._heads[i], gu.Var):  # pylint: disable=E1101
                temp[i] = self._heads[i].X
            else:
                temp[i] = self._heads[i]
        return temp.T

    def _init_boundary_heads(self):
        for v in self._bounds.values():
            for coord in v:
                self._heads[coord] = None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="aq.Grid.add_boundary_contaminant"><code class="name flex">
<span>def <span class="ident">add_boundary_contaminant</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds boundary (left, top, right, bottom) contaminants by
adding model contraint. Head values within aquifer next to
boundary are contrained to be greater than the boundary head</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>str</code></dt>
<dd>the boundary side ('left', 'top', 'right', 'bottom')</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_boundary_contaminant(self, *args):
    &#34;&#34;&#34;Adds boundary (left, top, right, bottom) contaminants by
        adding model contraint. Head values within aquifer next to
        boundary are contrained to be greater than the boundary head

        Parameters:
            *args (str): the boundary side (&#39;left&#39;, &#39;top&#39;, &#39;right&#39;, &#39;bottom&#39;)
    &#34;&#34;&#34;
    w, h = self._width, self._height
    for bound in args:
        bound = bound.lower()
        if bound == &#34;right&#34;:
            self._boundary_helper(h + 1, w, w + 1, &#34;x&#34;)
        elif bound == &#34;left&#34;:
            self._boundary_helper(h + 1, 1, 0, &#34;x&#34;)
        elif bound == &#34;top&#34;:
            self._boundary_helper(w + 1, 1, 0, &#34;y&#34;)
        elif bound == &#34;bottom&#34;:
            self._boundary_helper(w + 1, h, h + 1, &#34;y&#34;)
        else:
            raise ValueError(
                &#34;Boundary not specified correctly. Should be &#39;top&#39;, &#39;bottom&#39;, &#39;left&#39;, or &#39;right&#39;&#34;
            )
    self.Model.update()</code></pre>
</details>
</dd>
<dt id="aq.Grid.add_boundary_heads"><code class="name flex">
<span>def <span class="ident">add_boundary_heads</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Specifies the boundary (left, top, right, bottom) head value.
If a value is not provided for a boundary, it is assumed to
be a no-flow boundary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>str</code></dt>
<dd>the boundary side and its head value</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_boundary_heads(self, **kwargs):
    &#34;&#34;&#34;Specifies the boundary (left, top, right, bottom) head value.
        If a value is not provided for a boundary, it is assumed to 
        be a no-flow boundary.

        Parameters:
            **kwargs (str): the boundary side and its head value
    &#34;&#34;&#34;
    for k in kwargs.keys():
        if k.lower() not in [&#34;top&#34;, &#34;bottom&#34;, &#34;right&#34;, &#34;left&#34;]:
            raise ValueError(
                &#34;Unknown argument assignment. Must specify head for &#39;top&#39;, &#39;left&#39;, &#39;right&#39;, or &#39;bottom&#39;.&#34;
            )
        self._add_bounds(k.lower(), kwargs[k])</code></pre>
</details>
</dd>
<dt id="aq.Grid.add_cell_lengths"><code class="name flex">
<span>def <span class="ident">add_cell_lengths</span></span>(<span>self, dx, dy=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Specifies the height and width of the cells.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dx</code></strong> :&ensp;<code>float</code></dt>
<dd>length in x direction</dd>
<dt><strong><code>dy</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>specifies length in y direction. If not
specified, dy = dx.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_cell_lengths(self, dx: float, dy: float = None):
    &#34;&#34;&#34;Specifies the height and width of the cells.

        Parameters:
            dx (float): length in x direction
            dy (float, optional): specifies length in y direction. If not
                specified, dy = dx.
    &#34;&#34;&#34;
    self._dx = dx
    self._dy = dy if dy is not None else dx</code></pre>
</details>
</dd>
<dt id="aq.Grid.add_contaminant"><code class="name flex">
<span>def <span class="ident">add_contaminant</span></span>(<span>self, coords)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds contaminant to aquifer by adding constrint to model.
Cell heads surrounding contaminant are greater than or equal
to contaminant head.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coords</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The x,y coordinates of the contaminant.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_contaminant(self, coords: tuple):
    &#34;&#34;&#34;Adds contaminant to aquifer by adding constrint to model.
        Cell heads surrounding contaminant are greater than or equal
        to contaminant head.

        Parameters:
            coords (tuple): The x,y coordinates of the contaminant.
    &#34;&#34;&#34;
    self.contam_coords.append(coords)
    x, y = coords
    for i in [-1, 1]:
        if self._heads[x + i, y] is not None:
            self.Model.addConstr(self._heads[x + i, y] &gt;= self._heads[x, y])
        if self._heads[x, y + i] is not None:
            self.Model.addConstr(self._heads[x, y + i] &gt;= self._heads[x, y])
    self.Model.update()</code></pre>
</details>
</dd>
<dt id="aq.Grid.add_max_head"><code class="name flex">
<span>def <span class="ident">add_max_head</span></span>(<span>self, max_head=inf)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds upper bound for the head values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>max_head</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>max head value. Defaults to +inf.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_max_head(self, max_head: float = float(&#34;inf&#34;)):
    &#34;&#34;&#34;Adds upper bound for the head values.

        Parameters:
            max_head (float, optional): max head value. Defaults to +inf.
    &#34;&#34;&#34;
    self._max_head = max_head
    for i in self._heads:
        if isinstance(self._heads[i], gu.Var):  # pylint: disable=E1101
            self._heads[i].setAttr(&#34;ub&#34;, self._max_head)</code></pre>
</details>
</dd>
<dt id="aq.Grid.add_min_head"><code class="name flex">
<span>def <span class="ident">add_min_head</span></span>(<span>self, min_head=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds lower bound for the head values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>min_head</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>min head value. Defaults to 0.0.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_min_head(self, min_head: float = 0):
    &#34;&#34;&#34;Adds lower bound for the head values.

        Parameters:
            min_head (float, optional): min head value. Defaults to 0.0.
    &#34;&#34;&#34;
    self._min_head = min_head
    for i in self._heads:
        if isinstance(self._heads[i], gu.Var):  # pylint: disable=E1101
            self._heads[i].setAttr(&#34;lb&#34;, self._min_head)</code></pre>
</details>
</dd>
<dt id="aq.Grid.add_min_pump_rate"><code class="name flex">
<span>def <span class="ident">add_min_pump_rate</span></span>(<span>self, rate)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds lower bound for the sum of the pumping rates. Adds
constraint to model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>min pumping rate.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_min_pump_rate(self, rate: float):
    &#34;&#34;&#34;Adds lower bound for the sum of the pumping rates. Adds
        constraint to model.

        Parameters:
            rate (float): min pumping rate.
    &#34;&#34;&#34;
    self.Model.addConstr(self.wells.sum() &gt;= rate)</code></pre>
</details>
</dd>
<dt id="aq.Grid.add_objective"><code class="name flex">
<span>def <span class="ident">add_objective</span></span>(<span>self, num)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds objective function. Select from list:</p>
<p>1: Maximize total pumping.
2: Maximize heads throughout aquifer.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>num</code></strong> :&ensp;<code>int</code></dt>
<dd>The objective function selection.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_objective(self, num: int):
    &#34;&#34;&#34;Adds objective function. Select from list:

        1: Maximize total pumping.
        2: Maximize heads throughout aquifer.

        Parameters:
            num (int): The objective function selection.
    &#34;&#34;&#34;
    if num == 1:
        self.Model.setObjective(
            self.wells.sum(), gu.GRB.MAXIMIZE  # pylint: disable=E1101
        )
    elif num == 2:
        temp = []
        for i in self._heads:
            if isinstance(self._heads[i], gu.Var):  # pylint: disable=E1101
                temp.append(self._heads[i])
        self.Model.setObjective(sum(temp), gu.GRB.MAXIMIZE)  # pylint: disable=E1101
    else:
        raise ValueError(
            &#34;must add int corresponding to objective number. 1: max pumping. 2: max heads in aquifer.&#34;
        )
    self.Model.update()</code></pre>
</details>
</dd>
<dt id="aq.Grid.add_trans"><code class="name flex">
<span>def <span class="ident">add_trans</span></span>(<span>self, tx, sd=0, distribution='uniform')</span>
</code></dt>
<dd>
<section class="desc"><p>Adds transmissivity distribution functions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tx</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean of transmissivity in x-direction.</dd>
<dt><strong><code>sd</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Standard deviation for distribution
function. Default is 0.0.</dd>
<dt><strong><code>distribution</code></strong> :&ensp;<code>str</code></dt>
<dd>Sets the transmissivity distribution
function. Default is 'uniform.' Select from 'uniform',
'normal' or 'lognormal.'</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_trans(self, tx: float, sd: float = 0, distribution: str = &#34;uniform&#34;):
    &#34;&#34;&#34;Adds transmissivity distribution functions.

        Parameters:
            tx (float): Mean of transmissivity in x-direction.
            sd (float, optional): Standard deviation for distribution 
                function. Default is 0.0.
            distribution (str): Sets the transmissivity distribution 
                function. Default is &#39;uniform.&#39; Select from &#39;uniform&#39;, 
                &#39;normal&#39; or &#39;lognormal.&#39;
    &#34;&#34;&#34;
    self._Tx = self._dist_helper(tx, sd, distribution)
    self._Ty = self._dist_helper(tx, sd, distribution)</code></pre>
</details>
</dd>
<dt id="aq.Grid.add_units"><code class="name flex">
<span>def <span class="ident">add_units</span></span>(<span>self, length='m', time='d')</span>
</code></dt>
<dd>
<section class="desc"><p>Adds dimensional units.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>units for length. Default to 'm' (meters).</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>units for time. Default to 'd' (days).</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_units(self, length: str = &#34;m&#34;, time: str = &#34;d&#34;):
    &#34;&#34;&#34;Adds dimensional units.

        Parameters:
            length (str, optional): units for length. Default to &#39;m&#39; (meters).
            time (str, optional): units for time. Default to &#39;d&#39; (days).
    &#34;&#34;&#34;
    self._length = &#34;m&#34; if length == &#34;m&#34; else &#34;ft&#34;
    self._rate = f&#34;cm{time}&#34; if length == &#34;m&#34; else f&#34;cf{time}&#34;
    self._sink = f&#34;mp{time}&#34; if length == &#34;m&#34; else f&#34;fp{time}&#34;</code></pre>
</details>
</dd>
<dt id="aq.Grid.add_wells"><code class="name flex">
<span>def <span class="ident">add_wells</span></span>(<span>self, coords)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds the wells to the aquifer.</p>
<h2 id="parameters">Parameters</h2>
<p>coords (List(tuple)): The (x,y) coordinates for the wells.
Must be provided as a single tuple (x,y) or as a list
of tuples [(x1,y1), (x2,y2) &hellip;]</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_wells(self, coords):
    &#34;&#34;&#34;Adds the wells to the aquifer.

        Parameters:
            coords (List(tuple)): The (x,y) coordinates for the wells. 
                Must be provided as a single tuple (x,y) or as a list 
                of tuples [(x1,y1), (x2,y2) ...]
    &#34;&#34;&#34;
    if type(coords) is tuple:
        coords = [coords]
    if type(coords[0]) is not tuple:
        raise ValueError(
            &#34;Well coordinates must be added as a list of tuples, e.g. [(x1, y1), (x2, y2)]&#34;
        )
    for coord in coords:
        self.wells[coord] = self.Model.addVar(name=f&#34;pump{coord}&#34;, lb=float(&#34;-inf&#34;))
        self.well_coords.append(coord)
    self.Model.update()</code></pre>
</details>
</dd>
<dt id="aq.Grid.optimize"><code class="name flex">
<span>def <span class="ident">optimize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This function finalizes the model constraints, updates the model,
and then tries to solve the model. If optimal solution is found,
the head values are gathered for printing purposes later.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def optimize(self):
    &#34;&#34;&#34;This function finalizes the model constraints, updates the model,
        and then tries to solve the model. If optimal solution is found,
        the head values are gathered for printing purposes later.
    &#34;&#34;&#34;
    self._add_constraints()
    self.Model.update()
    self.Model.optimize()
    if (
        self.Model.Status == 2
    ):  # Status = 2 means optimal solution found and model is solved
        self._solved = True
        self._head_results = self._get_head_results()
        print(&#34;OPTIMIZATION COMPLETE&#34;)
    else:
        self._head_results = None
        print(&#34;OPTIMIZATION NOT COMPLETE&#34;)</code></pre>
</details>
</dd>
<dt id="aq.Grid.print_grid_results"><code class="name flex">
<span>def <span class="ident">print_grid_results</span></span>(<span>self, filename='heads')</span>
</code></dt>
<dd>
<section class="desc"><p>Prints grid head values to the terminal and to csv file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>filename (without extension) to
save grid head values.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def print_grid_results(self, filename: str = &#34;heads&#34;):
    &#34;&#34;&#34;Prints grid head values to the terminal and to csv file.

        Parameters:
            filename (str, optional): filename (without extension) to 
                save grid head values.
    &#34;&#34;&#34;
    if self._solved:
        np.savetxt(f&#34;{filename}.csv&#34;, self._head_results, fmt=&#34;%.5f&#34;, delimiter=&#34;,&#34;)
        print(f&#34;Results: in {self._length}&#34;)
        with np.printoptions(
            precision=3, suppress=True, nanstr=&#34;bound&#34;, floatmode=&#34;fixed&#34;
        ):
            print(self._head_results)
    else:
        print(&#34;No results to print.&#34;)</code></pre>
</details>
</dd>
<dt id="aq.Grid.print_map"><code class="name flex">
<span>def <span class="ident">print_map</span></span>(<span>self, filename='map', text=False, wells=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates heat map of the aquifer based on head values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>filename (without extension) to save
image of heat map.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Adds the numerical value to the map.
Default is False.
Really big aquifers will not show this value very well.</dd>
<dt><strong><code>wells</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Adds +/-W to the well locations.
Default is True. The W does not scale with aquifer size,
so it will not show up very well in really large aquifers.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def print_map(self, filename: str = &#34;map&#34;, text: bool = False, wells: bool = True):
    &#34;&#34;&#34;Generates heat map of the aquifer based on head values.

        Parameters:
            filename (str, optional): filename (without extension) to save 
                image of heat map.
            text (bool, optional): Adds the numerical value to the map.
                Default is False.
                Really big aquifers will not show this value very well.
            wells (bool, optional): Adds +/-W to the well locations. 
                Default is True. The W does not scale with aquifer size, 
                so it will not show up very well in really large aquifers.
    &#34;&#34;&#34;
    if self._solved:
        grid = self._head_results
        vmin = np.nanmin(grid)
        vmax = np.nanmax(grid)
        for x, y in self.contam_coords:
            grid[y][x] = vmax + 1
        current_cmap = plt.cm.get_cmap(&#34;Blues_r&#34;)
        current_cmap.set_bad(color=&#34;gray&#34;)
        current_cmap.set_over(color=&#34;red&#34;)
        plt.imshow(grid, cmap=current_cmap, vmin=vmin, vmax=vmax)
        for i, j in self.well_coords:
            label = &#34;-W&#34; if self.wells[(i, j)].X &gt;= 0 else &#34;+W&#34;
            plt.text(i, j, label, ha=&#34;center&#34;, va=&#34;center&#34;)
        if text:
            for (j, i), label in np.ndenumerate(grid):
                plt.text(i, j, round(label, 1), ha=&#34;center&#34;, va=&#34;center&#34;)
        plt.colorbar()
        plt.savefig(f&#34;{filename}.pdf&#34;, dpi=300)
        plt.show()
    else:
        print(&#34;No results to print.&#34;)</code></pre>
</details>
</dd>
<dt id="aq.Grid.print_pump_results"><code class="name flex">
<span>def <span class="ident">print_pump_results</span></span>(<span>self, filename='pumps')</span>
</code></dt>
<dd>
<section class="desc"><p>Prints pump values to the terminal and to txt file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>filename (without extension) to
save pump values.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def print_pump_results(self, filename: str = &#34;pumps&#34;):
    &#34;&#34;&#34;Prints pump values to the terminal and to txt file.

        Parameters:
            filename (str, optional): filename (without extension) to
                save pump values.
    &#34;&#34;&#34;
    if self._solved:
        with open(f&#34;{filename}.txt&#34;, &#34;w&#34;) as f:
            f.write(&#34;Pump Results\n&#34;)
            print(&#34;Pump Results&#34;)
            for key in self.wells:
                if isinstance(self.wells[key], gu.Var):  # pylint: disable=E1101
                    line = f&#34;{key}: {self.wells[key].X:10.5f} {self._sink}, head ({self._length}): {self._heads[key].X:6.2f}&#34;
                    print(line)
                    f.write(line + &#34;\n&#34;)
            q = self.wells.sum().getValue()
            print(f&#34;Total Flow (q): {q:.2f} {self._sink}&#34;)
            print(f&#34;Total Flow (W): {q*self._dx*self._dy:.2f} {self._rate}&#34;)
            f.write(f&#34;Total Flow (q): {q:.2f} {self._sink}\n&#34;)
            f.write(f&#34;Total Flow (W): {q*self._dx*self._dy:.2f} {self._rate}\n&#34;)
    else:
        print(&#34;No results to print.&#34;)</code></pre>
</details>
</dd>
<dt id="aq.Grid.print_report"><code class="name flex">
<span>def <span class="ident">print_report</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates lindo style report.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def print_report(self):
    &#34;&#34;&#34;Generates lindo style report.&#34;&#34;&#34;
    if self._solved:
        lindo(self.Model)
    else:
        print(&#34;No results to print.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="aq.make_zero_tuple_dict" href="#aq.make_zero_tuple_dict">make_zero_tuple_dict</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aq.Grid" href="#aq.Grid">Grid</a></code></h4>
<ul class="">
<li><code><a title="aq.Grid.add_boundary_contaminant" href="#aq.Grid.add_boundary_contaminant">add_boundary_contaminant</a></code></li>
<li><code><a title="aq.Grid.add_boundary_heads" href="#aq.Grid.add_boundary_heads">add_boundary_heads</a></code></li>
<li><code><a title="aq.Grid.add_cell_lengths" href="#aq.Grid.add_cell_lengths">add_cell_lengths</a></code></li>
<li><code><a title="aq.Grid.add_contaminant" href="#aq.Grid.add_contaminant">add_contaminant</a></code></li>
<li><code><a title="aq.Grid.add_max_head" href="#aq.Grid.add_max_head">add_max_head</a></code></li>
<li><code><a title="aq.Grid.add_min_head" href="#aq.Grid.add_min_head">add_min_head</a></code></li>
<li><code><a title="aq.Grid.add_min_pump_rate" href="#aq.Grid.add_min_pump_rate">add_min_pump_rate</a></code></li>
<li><code><a title="aq.Grid.add_objective" href="#aq.Grid.add_objective">add_objective</a></code></li>
<li><code><a title="aq.Grid.add_trans" href="#aq.Grid.add_trans">add_trans</a></code></li>
<li><code><a title="aq.Grid.add_units" href="#aq.Grid.add_units">add_units</a></code></li>
<li><code><a title="aq.Grid.add_wells" href="#aq.Grid.add_wells">add_wells</a></code></li>
<li><code><a title="aq.Grid.optimize" href="#aq.Grid.optimize">optimize</a></code></li>
<li><code><a title="aq.Grid.print_grid_results" href="#aq.Grid.print_grid_results">print_grid_results</a></code></li>
<li><code><a title="aq.Grid.print_map" href="#aq.Grid.print_map">print_map</a></code></li>
<li><code><a title="aq.Grid.print_pump_results" href="#aq.Grid.print_pump_results">print_pump_results</a></code></li>
<li><code><a title="aq.Grid.print_report" href="#aq.Grid.print_report">print_report</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>